{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview respo states for Resource Policy and is tiny, user friendly tool for building RBAC systems based on single yml file, mainly with FastAPI framework in mind. In most cases \u2013 for even large set of roles and organizations \u2013 single file would be enough to provide restricting system access. Note, every piece of code in the docs is a tested python/yml file, feel free to use it. 1. YML file with defined permissions, organizations and roles 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # respo-example.yml metadata : name : Just an example file permissions : - metadata : label : user resources : - label : user.read_basic - label : user.read_all - label : user.create rules : - when : user.read_all then : - user.read_basic organizations : - metadata : label : default permissions : [] roles : - metadata : label : foo organization : default permissions : - label : default.user.create - label : default.user.read_all Note, this is very minimal showcase file, without (optional) names and descriptions fields for every object so it takes less space. There are 4 sections: metadata , it will be automatically populated with things like last_modify datetime and created_at fields permissions , list of permission \"groups\" (only one \u2013 \"user\" above), where you specify all possible permission names in resources and custom rules (nested as you like) so stronger labels will force weaker organizations , list of predefined names and optionally \u2013 ensured permissions by default. You may choose to split such as \"superadmins\", \"admins\", \"normal users\", but also \"company A\", \"company B\" etc. roles , they belong strictly to one of organizations, with set of permissions. Not allowing one-to-many role to organization helps to avoid mistakes. 2. Parse YML file using respo CLI interface Thanks to Typer , respo has powerful cli interface based on python annotations. 1 2 3 respo --help # prints all available commands respo create respo-example.yml # create model from file And thats it, yml file got validated and pickled by default to .respo_cache/__auto__respo_model.bin file. 3. Using created respo model in dummy FastAPI app 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # main.py - example FastAPI app using respo from fastapi import FastAPI from pydantic import BaseModel from respo import create_respo_client , get_respo_model , Client app = FastAPI () respo = get_respo_model () # You would probably use database, this is just a simple User \"table\" class User ( BaseModel ): name : str organizations : str = \"\" roles : str = \"\" def respo_client ( self ) -> Client : # [\"foo1\", \"foo2\"] or \"foo1 foo2\" syntax supported return create_respo_client ( roles = self . roles , organizations = self . organizations , ) @app . get ( \"/ {organization} /user_read_all\" ) async def user_read_all ( organization : str ): user = User ( name = \"user\" , roles = \"foo\" ) if respo . check ( f \" { organization } .user.read_all\" , user . respo_client ()): return { \"message\" : \"Granted!\" } return { \"message\" : \"Denied!\" } @app . get ( \"/ {organization} /user_read_basic\" ) async def user_read_basic ( organization : str ): user = User ( name = \"user\" , roles = \"foo\" ) if respo . check ( f \" { organization } .user.read_basic\" , user . respo_client ()): return { \"message\" : \"Granted!\" } return { \"message\" : \"Denied!\" } Insights: Every endpoint has exactly and only exactly ONE UNIQUE PERMISSION Nested rules are resolved (note, no user.read_basic directly in foo role declaration from above, it was resolved by respo) so no need for complex if statements anywhere, any permission inheritance is done during build time using respo create some_file Every endpoint must have organization in path, so that different organizations are totally independent","title":"Overview"},{"location":"#overview","text":"respo states for Resource Policy and is tiny, user friendly tool for building RBAC systems based on single yml file, mainly with FastAPI framework in mind. In most cases \u2013 for even large set of roles and organizations \u2013 single file would be enough to provide restricting system access. Note, every piece of code in the docs is a tested python/yml file, feel free to use it.","title":"Overview"},{"location":"#1-yml-file-with-defined-permissions-organizations-and-roles","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # respo-example.yml metadata : name : Just an example file permissions : - metadata : label : user resources : - label : user.read_basic - label : user.read_all - label : user.create rules : - when : user.read_all then : - user.read_basic organizations : - metadata : label : default permissions : [] roles : - metadata : label : foo organization : default permissions : - label : default.user.create - label : default.user.read_all Note, this is very minimal showcase file, without (optional) names and descriptions fields for every object so it takes less space. There are 4 sections: metadata , it will be automatically populated with things like last_modify datetime and created_at fields permissions , list of permission \"groups\" (only one \u2013 \"user\" above), where you specify all possible permission names in resources and custom rules (nested as you like) so stronger labels will force weaker organizations , list of predefined names and optionally \u2013 ensured permissions by default. You may choose to split such as \"superadmins\", \"admins\", \"normal users\", but also \"company A\", \"company B\" etc. roles , they belong strictly to one of organizations, with set of permissions. Not allowing one-to-many role to organization helps to avoid mistakes.","title":"1. YML file with defined permissions, organizations and roles"},{"location":"#2-parse-yml-file-using-respo-cli-interface","text":"Thanks to Typer , respo has powerful cli interface based on python annotations. 1 2 3 respo --help # prints all available commands respo create respo-example.yml # create model from file And thats it, yml file got validated and pickled by default to .respo_cache/__auto__respo_model.bin file.","title":"2. Parse YML file using respo CLI interface"},{"location":"#3-using-created-respo-model-in-dummy-fastapi-app","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # main.py - example FastAPI app using respo from fastapi import FastAPI from pydantic import BaseModel from respo import create_respo_client , get_respo_model , Client app = FastAPI () respo = get_respo_model () # You would probably use database, this is just a simple User \"table\" class User ( BaseModel ): name : str organizations : str = \"\" roles : str = \"\" def respo_client ( self ) -> Client : # [\"foo1\", \"foo2\"] or \"foo1 foo2\" syntax supported return create_respo_client ( roles = self . roles , organizations = self . organizations , ) @app . get ( \"/ {organization} /user_read_all\" ) async def user_read_all ( organization : str ): user = User ( name = \"user\" , roles = \"foo\" ) if respo . check ( f \" { organization } .user.read_all\" , user . respo_client ()): return { \"message\" : \"Granted!\" } return { \"message\" : \"Denied!\" } @app . get ( \"/ {organization} /user_read_basic\" ) async def user_read_basic ( organization : str ): user = User ( name = \"user\" , roles = \"foo\" ) if respo . check ( f \" { organization } .user.read_basic\" , user . respo_client ()): return { \"message\" : \"Granted!\" } return { \"message\" : \"Denied!\" } Insights: Every endpoint has exactly and only exactly ONE UNIQUE PERMISSION Nested rules are resolved (note, no user.read_basic directly in foo role declaration from above, it was resolved by respo) so no need for complex if statements anywhere, any permission inheritance is done during build time using respo create some_file Every endpoint must have organization in path, so that different organizations are totally independent","title":"3. Using created respo model in dummy FastAPI app"},{"location":"Install/","text":"Install Installation is as simple as: 1 pip install respo You can also customize some default settings using environment variables 1 2 3 4 5 6 7 8 RESPO_BINARY_FILE_NAME = \".respo_cache/__auto__respo_model.bin\" # Name of file where pickled model will be saved RESPO_DEFAULT_EXPORT_FILE = \"__auto__respo_model\" # default name of exported model as a field after exporting RESPO_CHECK_FORCE = false # if True, no validation of \"Client\" will happen when using respo.check","title":"Install"},{"location":"Install/#install","text":"Installation is as simple as: 1 pip install respo You can also customize some default settings using environment variables 1 2 3 4 5 6 7 8 RESPO_BINARY_FILE_NAME = \".respo_cache/__auto__respo_model.bin\" # Name of file where pickled model will be saved RESPO_DEFAULT_EXPORT_FILE = \"__auto__respo_model\" # default name of exported model as a field after exporting RESPO_CHECK_FORCE = false # if True, no validation of \"Client\" will happen when using respo.check","title":"Install"},{"location":"User_Guide/","text":"User Guide To be continued...","title":"User Guide"},{"location":"User_Guide/#user-guide","text":"To be continued...","title":"User Guide"}]}